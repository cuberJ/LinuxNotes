# 文件与目录权限

## 文件权限

#### 作用

用于控制进程对系统中文件和目录的访问

#### 级别

分为三个级别：文件主，同组用户，其他用户

每个文件有唯一的属主

#### 权限分类

1. 普通文件权限：

   1. 读，写，可执行
   2. 不可写文件可被删除

2. 两类可执行文件

   1. 程序文件：二进制的CPU指令集合，满足操作系统规定的格式，可以被加载运行
   2. 脚本文件：实质上是文本文件，采用解释器逐行解释并同时进行运行（类似Java和Python）
      默认的解释程序是/bin/sh，也可以在文件的第一行指定解释程序（这时文件第一行必须以 `#!`开头:比如`#! /bin/bash`）



## 目录权限

3. 读权限：

   1. 没有读权限，则目录表文件不许读，ls指令会失败

2. 写权限

   1. 目录表文件自身没有写权限，则目录表不许写，同时也不可以创建，删除和改名该目录下的文件
   2. 目录表无写权限，但可以对该目录下的文件内容进行修改，因为修改文件不需要修改目录文件，只需要修改i节点。由于目录表中只是保存了i节点所在的地址而不是i节点的内容，所以文件修改成功

3. 执行权限

   ```shell
   cat  /a/b/c
   # 使用者在调用进程cat时应当对/  , /a,   /a/b均有x权限，对c文件有读权限，否则操作失败
   ```

   

4. sticky权限（粘着位）

   1. 具有sticky属性的可执行文件会尽量常驻内存或者交换区，提高效率
   2. 具有写权限且具有sticky属性的文件，只有文件主可以删除，其他用户不可以

   

## 确定文件权限

### 使用ls命令

```shell
ls -l # 长格式
ls -d # 显示目录自身的权限
```



### 修改权限chmod

```shell
# 格式如下
chmod [ugoa] [+-=] [rwxst] 文件名列表
# ugoa:u-文件主权限  g-同组用户权限  o-其他用户权限  a-上述的三级权限
# +-=：分别是给予，删除,维持
# r是读权限，w写权限，x执行权限
```

```shell
chmod go-rwx *.[ch] # 对于同组以及其他用户，废除他们的读写和操作所有c语言和头文件的权限
```

该指令还有数字模式

```shell
chmod 644 xyz1 xyz2
# 6 = 110  4 = 100  4 = 100
# 对应的权限分别为：
#     rw-      r--      r--
# 也就是该文件的总权限为rw-r--r--
```

<font color = red>只有文件主和超级用户可以修改文件权限</font>



### umask指令：控制文件/目录的初始权限，是shell的内部命令

```shell
umask # 打印当前的umask值
umask 022 # 将当前进程的权限掩码设为022
```

umask采用的数字编码实质上是<font color = red>掩码</font>.比如，umask 022中：

022 = 000 010 010，为1的部分表示删除对应的权限，也就是删除组用户和其他用户的w权限





#### 三级权限

##### 针对问题

不同用户对于文件的权限要么全部拥有，要么完全无法操作，没法进行部分访问



# Shell批处理脚本

## Shell特点

1.  批处理，执行效率比算法语言（C，C++等）低
2. 面向命令处理的语言，通常在文件某一行的最左边写入执行命令来执行操作
3.  具有历史替换功能（通过上下键翻阅命令的历史）
4.  <font color = red>设计思路和C语言一样，本身设计的很精炼，但提供了灵活的机制（管道，重定向等），即：策略与机制相分离。shell只负责按照条件调用脚本，而执行时的方式（控制流程的判断，选择等）都由别的进程控制</font>

## bash启动

### 三种启动方式

#### 注册shell

与注册用户绑定，在用户登录后自动执行的shell。该文件位于用户主目录下的`.bash_profile`文件中

#### 自定义脚本文件

以编辑文件 lsdir 为例<font color = red>不一定非要以.sh为后缀，只要对该文件有x权限即可</font>

执行的方式有如下几种：

```shell
bash < lsdir  #无法携带参数
bash -x lsdir  
bash lsdir /usr
chmod 777 lsdir; ./lsdir /usr
```



#### 键入bash命令

是一种交互式的shell

#### 脚本解释器

用来解释另一个脚本 



### 历史表

先前键入的命令存于历史表中，编号递增，表的大小由HISTSIZ设定，修改的配置放入`~/.bashrc`中。

通过history可以查看内部指令



#### 历史替换

1. 人机交互的时候直接使用上下箭头可以替换为历史指令

2. `!!`可以直接引用上一命令

   `!str` 可以直接引用上一个以str开头的命令

#### 别名替换

通过命令`alias`在别名表中增加一个别名

```shell
alias dir="ls -flad /usr"
alias p="ping 127.0.0.1"
```



系统还可以重载已有的指令

```shell
alias rm="rm -i"
```



### TAB补全

每行的首个单词会补全为命令，在补全时去$PATH目录下搜索文件名

行中的单词会补全为文件名



## 重定向

1. `<<word` 从shell脚本中获取数据

   ```shell
   cat << TOAST  #这种句子一般是写在一个脚本文件中。在这句话之后，脚本文件中的每一行都会作为cat的输入，直到在文件中再次读到TOAST
   ```



#### 标准输出：stdout输出重定向

1. `>filename`将stdout重定向到文件filename，如果文件已经存在，则覆盖
2. `>>filename`将stdout重定向追加到文件尾



#### 标准错误输出：stderr输出重定向

1. Linux系统中，打印在终端界面上的运行结果分为两种：标准输出和标准错误输出。两种输出走的是不同的通道。如果不做区分，在显示上没有太大差别。可以通过对输出重定向，将两个通道的数据写入两个文件进行区分（防止报错混在正确的输出里）。
2. `2>filename`将文件句柄2重定向到文件filename
3. `2>&1`将文件句柄2（也就是错误输出的管道）重定向到文件描述符1指向的文件（文件描述符1是系统给定的，为stdout的输出重定向的管道。0号通道指向的是键盘）
4. <font color = red>允许对除了0，1，2以外的其他文件句柄输入或者输出重定向</font>

实例

```shell
./test.c > stdout.log  # 将test.c执行结果中的标准输出传到log文件中，不显示在屏幕上
./test.c > stdout.log 2> stderr.log  # 将test.c的标准输出放入stdout.log文件中，将报错信息输出到stderr.log文件中
./test.c 2>&1 > mydata.log  # 指令执行的顺序如下：先将2定位到1的输出方式（此时1还是输出到屏幕），再将1的输出重定向到文件。最终，标准输出会定向到log中，而错误输出会打印在屏幕上
```





